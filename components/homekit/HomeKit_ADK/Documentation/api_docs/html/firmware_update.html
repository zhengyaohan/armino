

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Firmware Update Service &mdash; HomeKit ADK  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/tabs.css" type="text/css" />
  <link rel="stylesheet" href="_static/collapsible-lists/css/tree_view.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/tabs.js"></script>
        <script src="_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="HomeKit Bridge" href="homekit_bridge.html" />
    <link rel="prev" title="Apple TV Remote" href="appletv_remote.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> HomeKit ADK
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="adk_architecture.html">ADK Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="adk_directory_structure.html">ADK Directory Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="docker.html">Docker with ADK</a></li>
</ul>
<p class="caption"><span class="caption-text">Step-by-step Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started with ADK</a></li>
<li class="toctree-l1"><a class="reference internal" href="raspi_setup.html">Raspberry Pi Setup Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="bct.html">Bonjour Conformance Test (BCT)</a></li>
<li class="toctree-l1"><a class="reference internal" href="wac_on_raspberrypi.html">WAC on Raspberry Pi</a></li>
<li class="toctree-l1"><a class="reference internal" href="camera_on_darwin.html">Camera on macOS</a></li>
</ul>
<p class="caption"><span class="caption-text">Troubleshooting ADK</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="interact_with_applications.html">Interacting with ADK applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="troubleshooting.html">Troubleshooting ADK</a></li>
<li class="toctree-l1"><a class="reference internal" href="writing_unit_tests.html">Writing Unit Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug_adk.html">Debugging ADK Applications</a></li>
</ul>
<p class="caption"><span class="caption-text">ADK Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="accessory_development.html">Accessory Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="accessory_pairing.html">Accessory Pairing</a></li>
<li class="toctree-l1"><a class="reference internal" href="accessory_authentication.html">Accessory Authentication</a></li>
<li class="toctree-l1"><a class="reference internal" href="provisioning_tools.html">Provisioning Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="ADK_Memory_Usage_and_Requirements.html">Memory Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="crypto.html">Cryptographic Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="make_options.html">Compile Time Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="coding_convention.html">Coding Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html">ADK Migration Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">HomeKit Services</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="accessory_diagnostics.html">Accessory Diagnostics Service</a></li>
<li class="toctree-l1"><a class="reference internal" href="accessory_metrics.html">Accessory Metrics Service</a></li>
<li class="toctree-l1"><a class="reference internal" href="adaptive_light.html">Adaptive Lighting Service</a></li>
<li class="toctree-l1"><a class="reference internal" href="appletv_remote.html">Apple TV Remote</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Firmware Update Service</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#compile">Compile</a></li>
<li class="toctree-l3"><a class="reference internal" href="#run">Run</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#implementation-details">Implementation Details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#additional-information">Additional Information</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#unified-accessory-restore-protocol-uarp">Unified Accessory Restore Protocol (UARP)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#superbinary-image-format">SuperBinary Image Format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#homekit-data-stream-hds">HomeKit Data Stream (HDS)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hap-firmware-update-service">HAP Firmware Update Service</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hap-implementation">HAP Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pal-implementation">PAL Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#app-implementation">App Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-uarp-callback-flow">Example UARP callback flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transfer-concepts">Transfer Concepts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#controller-disconnect">Controller disconnect</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessory-driven-resume">Accessory-driven resume</a></li>
<li class="toctree-l4"><a class="reference internal" href="#competing-offers">Competing offers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#minimum-firmware-version">Minimum firmware version</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transport-optimization">Transport Optimization</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="homekit_bridge.html">HomeKit Bridge</a></li>
<li class="toctree-l1"><a class="reference internal" href="ip_camera.html">IP Camera</a></li>
<li class="toctree-l1"><a class="reference internal" href="lock_profile.html">Lock Profile</a></li>
<li class="toctree-l1"><a class="reference internal" href="stateless_programmable_switch.html">Stateless Programmable Switch</a></li>
<li class="toctree-l1"><a class="reference internal" href="thread.html">HAP over Thread Profile</a></li>
<li class="toctree-l1"><a class="reference internal" href="wifi_reconfiguration_feature.html">WiFi Reconfiguration Service</a></li>
</ul>
<p class="caption"><span class="caption-text">PAL APIs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="_api_docs/dir_PAL.html">Directory PAL</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">HomeKit ADK</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Firmware Update Service</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/firmware_update.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="firmware-update-service">
<h1>Firmware Update Service<a class="headerlink" href="#firmware-update-service" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This document describes the firmware update feature provided by the ADK and how to integrate it into a HomeKit
accessory. It was developed in accordance with the HomeKit Accessory Protocol Firmware Update specification and the
Unified Accessory Restore Protocol (UARP) development guide.</p>
<div class="section" id="compile">
<h3>Compile<a class="headerlink" href="#compile" title="Permalink to this headline">¶</a></h3>
<p>You must have all the <a class="reference internal" href="getting_started.html"><span class="doc">prerequisites</span></a> for your development platform to compile the ADK. Once all the
prerequisites are installed for your platform, run the following to compile ADK with firmware update feature for IP
accessories with TCP support:</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-0-bWFjT1M=" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-0-bWFjT1M=" name="bWFjT1M=" role="tab" tabindex="0">macOS</button><button aria-controls="panel-0-TGludXg=" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-0-TGludXg=" name="TGludXg=" role="tab" tabindex="-1">Linux</button><button aria-controls="panel-0-UmFzcGJlcnJ5IFBp" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-0-UmFzcGJlcnJ5IFBp" name="UmFzcGJlcnJ5IFBp" role="tab" tabindex="-1">Raspberry Pi</button><button aria-controls="panel-0-Tm9yZGljIG5SRjUy" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-0-Tm9yZGljIG5SRjUy" name="Tm9yZGljIG5SRjUy" role="tab" tabindex="-1">Nordic nRF52</button></div><div aria-labelledby="tab-0-bWFjT1M=" class="sphinx-tabs-panel group-tab" id="panel-0-bWFjT1M=" name="bWFjT1M=" role="tabpanel" tabindex="0"><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make <span class="nv">TARGET</span><span class="o">=</span>Darwin <span class="nv">HAP_FIRMWARE_UPDATE</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
<p>For BLE:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make <span class="nv">TARGET</span><span class="o">=</span>Darwin <span class="nv">PROTOCOLS</span><span class="o">=</span>BLE <span class="nv">HAP_HDS_TRANSPORT_OVER_HAP</span><span class="o">=</span><span class="m">1</span> <span class="nv">HAP_FIRMWARE_UPDATE</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
<p>For Thread:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make <span class="nv">TARGET</span><span class="o">=</span>Darwin <span class="nv">PROTOCOLS</span><span class="o">=</span>THREAD <span class="nv">HAP_HDS_TRANSPORT_OVER_HAP</span><span class="o">=</span><span class="m">1</span> <span class="nv">HAP_FIRMWARE_UPDATE</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-0-TGludXg=" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-0-TGludXg=" name="TGludXg=" role="tabpanel" tabindex="0"><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make <span class="nv">TARGET</span><span class="o">=</span>Linux <span class="nv">HAP_FIRMWARE_UPDATE</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-0-UmFzcGJlcnJ5IFBp" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-0-UmFzcGJlcnJ5IFBp" name="UmFzcGJlcnJ5IFBp" role="tabpanel" tabindex="0"><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make <span class="nv">TARGET</span><span class="o">=</span>Raspi <span class="nv">HAP_FIRMWARE_UPDATE</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
<p>For BLE:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make <span class="nv">TARGET</span><span class="o">=</span>Raspi <span class="nv">PROTOCOLS</span><span class="o">=</span>BLE <span class="nv">HAP_HDS_TRANSPORT_OVER_HAP</span><span class="o">=</span><span class="m">1</span> <span class="nv">HAP_FIRMWARE_UPDATE</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-0-Tm9yZGljIG5SRjUy" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-0-Tm9yZGljIG5SRjUy" name="Tm9yZGljIG5SRjUy" role="tabpanel" tabindex="0"><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make <span class="nv">TARGET</span><span class="o">=</span>nRF52 <span class="nv">HAP_HDS_TRANSPORT_OVER_HAP</span><span class="o">=</span><span class="m">1</span> <span class="nv">HAP_FIRMWARE_UPDATE</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
<p>For Thread:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make <span class="nv">TARGET</span><span class="o">=</span>nRF52 <span class="nv">PROTOCOLS</span><span class="o">=</span>THREAD <span class="nv">HAP_HDS_TRANSPORT_OVER_HAP</span><span class="o">=</span><span class="m">1</span> <span class="nv">HAP_FIRMWARE_UPDATE</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
</div></div>
</div>
<div class="section" id="run">
<h3>Run<a class="headerlink" href="#run" title="Permalink to this headline">¶</a></h3>
<p>Please follow instructions at <a class="reference external" href="getting_started.html#step-5-running-an-adk-application">Running an ADK Application</a> to
run an ADK sample application.</p>
</div>
</div>
<div class="section" id="implementation-details">
<h2>Implementation Details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<p>The steps required to integrate the ADK firmware update feature into a HomeKit accessory are as follows:</p>
<ul class="simple">
<li><p>Add platform support, if needed, by adding <code class="docutils literal notranslate"><span class="pre">PAL/&lt;platform&gt;/HAPPlatformUARP.&lt;h|c&gt;</span></code>.</p></li>
<li><p>Include the firmware update service in the accessory’s services list.</p></li>
<li><p>Include the HDS transport management service in the accessory’s services list.</p></li>
<li><p>Initialize HDS with support for UARP.</p></li>
<li><p>Initialize the UARP and firmware update modules.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">Applications/Common/Helper/FirmwareUpdate.c</span></code> as a starting point, implement the HAP firmware update state
callback and the UARP accessory callbacks, including appropriate image staging and apply routines and corresponding
state tracking/notifications.</p></li>
<li><p>Enable the feature with the <code class="docutils literal notranslate"><span class="pre">HAP_FIRMWARE_UPDATE</span></code> build flag.</p></li>
<li><p>Tune <code class="docutils literal notranslate"><span class="pre">kUARPDataChunkSize</span></code>, if needed, based on memory and performance tradeoff.</p></li>
</ul>
<div class="section" id="additional-information">
<h3>Additional Information<a class="headerlink" href="#additional-information" title="Permalink to this headline">¶</a></h3>
<p>Support for firmware updates directly through HomeKit minimizes the effort required by accessory vendors to support
updates and improves the user experience. The ADK implements the necessary framework for initiating a firmware update
and receiving the new firmware image onto the device. The accessory is required to stage the image into memory and
implement an apply routine as appropriate based upon the system design and underlying platform.</p>
<div class="section" id="unified-accessory-restore-protocol-uarp">
<h4>Unified Accessory Restore Protocol (UARP)<a class="headerlink" href="#unified-accessory-restore-protocol-uarp" title="Permalink to this headline">¶</a></h4>
<p>UARP is the protocol over which iOS controllers may notify an accessory of an available firmware update, the update
image is transferred to the device, and apply requests are issued. The ADK integrates the UARP accessory library
referenced in the UARP development guide and provides an API for accessory vendors to simplify integration of the
firmware update feature with the ADK.</p>
</div>
<div class="section" id="superbinary-image-format">
<h4>SuperBinary Image Format<a class="headerlink" href="#superbinary-image-format" title="Permalink to this headline">¶</a></h4>
<p>UARP relies on the SuperBinary Image Format, which is a wrapper around one or more firmware images or assets. It
consists of an overall header, payload header(s), and payload(s). The SuperBinary header and payload header(s) may
have associated metadata which is meant for the accessory to consume and perform operations which the controller would
not know how to interpret or process. More information on the SuperBinary format be found in <em>Section 3 - SuperBinary</em>
of the UARP development guide.</p>
</div>
<div class="section" id="homekit-data-stream-hds">
<h4>HomeKit Data Stream (HDS)<a class="headerlink" href="#homekit-data-stream-hds" title="Permalink to this headline">¶</a></h4>
<p>HDS is a message protocol built on a bidirectional byte stream. HDS supports various higher-level protocols, including
the stream protocol, which provides a generic data pipe for UARP messages between the iOS controller and accessory.
HDS may be run over TCP or HAP itself, which allows firmware updates to be supported on all underlying HAP transports.
Additional information regarding transport-specific HDS requirements is available in <em>Section 9 - HomeKit Data Stream</em>
of <em>HomeKit Accessory Protocol Specification</em>.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>    +-----------------------+
    <span class="p">|</span>          UARP         <span class="p">|</span>
    +-----------------------+
    <span class="p">|</span>    Stream Protocol    <span class="p">|</span>
    +-----------------------+
    <span class="p">|</span>    HDS Dispatcher     <span class="p">|</span>
    +-----------------------+
    <span class="p">|</span>          HDS          <span class="p">|</span>
    +-----------------------+
    <span class="p">|</span>  Transport <span class="o">(</span>TCP/HAP<span class="o">)</span>  <span class="p">|</span>
    +-----------------------+
</pre></div>
</div>
</div>
<div class="section" id="hap-firmware-update-service">
<h4>HAP Firmware Update Service<a class="headerlink" href="#hap-firmware-update-service" title="Permalink to this headline">¶</a></h4>
<p>The service consists of two required characteristics:</p>
<ul class="simple">
<li><p>Firmware Update Readiness</p></li>
<li><p>Firmware Update Status</p></li>
</ul>
<p>These characteristics allow iOS controllers to query state information from the accessory which is outside the scope of
UARP or is required when an HDS session is not active. The accessory is required to maintain this state which will be
retrieved by the HAP module on characteristic reads. For characteristics which support notify permissions, the accessory
is required to initiate the notification when relevant state changes via <code class="docutils literal notranslate"><span class="pre">HAPAccessoryServerRaiseEvent()</span></code>.</p>
<p>Requirements regarding state transitions and accessory expectations are provided in <em>Section 2.1 - Accessory Firmware
Update Design</em> of the HAP specification.</p>
</div>
</div>
<div class="section" id="hap-implementation">
<h3>HAP Implementation<a class="headerlink" href="#hap-implementation" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p><em>HAP/HAP+API.h</em></p>
<ul class="simple">
<li><p>Defines the accessory firmware update state structure and corresponding state retrieval callback which must be
implemented by the accessory.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">* Accessory firmware update state.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Update duration (seconds).</span>
<span class="cm">     *</span>
<span class="cm">     * - The amount of time the accessory is expected to be unresponsive while applying an update. The duration covers</span>
<span class="cm">     *   the time from which the apply request is received until the accessory is available for communication again.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">updateDuration</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The current state of the firmware update process.</span>
<span class="cm">     *</span>
<span class="cm">     * - For state definitions, reference HAPCharacteristicValue_FirmwareUpdateStatus_FirmwareUpdateState.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">updateState</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Staging not ready reason.</span>
<span class="cm">     *</span>
<span class="cm">     * - If cleared, the accessory is ready to stage a firmware update. For bit definitions, reference</span>
<span class="cm">     *   HAPCharacteristicValue_FirmwareUpdateReadiness_StagingNotReadyReason.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">stagingNotReadyReason</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Update not ready reason.</span>
<span class="cm">     *</span>
<span class="cm">     * - If cleared, the accessory is ready to apply a firmware update. For bit definitions, reference</span>
<span class="cm">     *   HAPCharacteristicValue_FirmwareUpdateReadiness_UpdateNotReadyReason.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">updateNotReadyReason</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Staged firmware version.</span>
<span class="cm">     *</span>
<span class="cm">     * - The staged version string must conform to the same format as that required by the Firmware Revision</span>
<span class="cm">     *   characteristic. If there is no staged firmware, this pointer must be NULL.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">_Nullable</span><span class="w"> </span><span class="n">stagedFirmwareVersion</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">HAPAccessoryFirmwareUpdateState</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Firmware update specific callbacks.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The callback used to get the accessory firmware update state.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      server               Accessory server.</span>
<span class="cm">     * @param      accessory            Accessory being accessed.</span>
<span class="cm">     * @param      accessoryState       Pointer to state structure.</span>
<span class="cm">     * @param      context              The context parameter given to the HAPAccessoryServerCreate function.</span>
<span class="cm">     *</span>
<span class="cm">     * @return kHAPError_None           If successful.</span>
<span class="cm">     * @return kHAPError_Busy           If the request failed temporarily.</span>
<span class="cm">     * @return kHAPError_Unknown        If unable to retrieve accessory firmware update state.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="n">HAP_RESULT_USE_CHECK</span><span class="w"></span>
<span class="w">    </span><span class="nf">HAPError</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">_Nullable</span><span class="w"> </span><span class="n">getAccessoryState</span><span class="p">)(</span><span class="w"></span>
<span class="w">            </span><span class="n">HAPAccessoryServerRef</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">HAPAccessoryFirmwareUpdateState</span><span class="o">*</span><span class="w"> </span><span class="n">accessoryState</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">_Nullable</span><span class="w"> </span><span class="n">context</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">firmwareUpdate</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="pal-implementation">
<h3>PAL Implementation<a class="headerlink" href="#pal-implementation" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><em>PAL/</em>/HAPPlatformUARP.h*</p>
<ul>
<li><p>Provides platform-specific includes for byte order conversion routines required by the UARP library.</p></li>
</ul>
</li>
<li><p><em>PAL/</em>/HAPPlatformUARP.c*</p>
<ul>
<li><p>Implements the ADK platform interface required by the UARP library, including logging and byte order conversion.
Note that an implementation is required per-platform to compile, but all implementations symlink to the POSIX
implementation.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="app-implementation">
<h3>App Implementation<a class="headerlink" href="#app-implementation" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p><em>Applications/Common/Helper/UARP.h</em></p>
<ul class="simple">
<li><p>Defines the data chunk size used when pulling an image. This also corresponds to the size of the buffer the
accessory is expected to consume during staging.</p></li>
<li><p>Details the accessory UARP API. This API consists of callbacks for handling UARP events which must be implemented by
the accessory as well as functions for initialization and control of the staging flow.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * UARP callbacks for application handling.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The callback used to notify the accessory of an asset offering.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      server              Accessory server.</span>
<span class="cm">     * @param      accessory           The accessory that provides the service.</span>
<span class="cm">     * @param      assetVersion        Asset version.</span>
<span class="cm">     * @param      assetTag            Asset tag identifier.</span>
<span class="cm">     * @param      assetLength         Total asset length.</span>
<span class="cm">     * @param      assetNumPayloads    Number of payloads in the asset.</span>
<span class="cm">     * @param[out] shouldAccept        Accessory indicator to accept or deny the asset.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">assetOffered</span><span class="p">)(</span><span class="w"></span>
<span class="w">            </span><span class="n">HAPAccessoryServer</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">UARPVersion</span><span class="o">*</span><span class="w"> </span><span class="n">assetVersion</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">assetTag</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">assetLength</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">assetNumPayloads</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">shouldAccept</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The callback used to notify the accessory of an asset metadata TLV for processing.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      server          Accessory server.</span>
<span class="cm">     * @param      accessory       The accessory that provides the service.</span>
<span class="cm">     * @param      tlvType         Type field of TLV.</span>
<span class="cm">     * @param      tlvLength       Length field of TLV.</span>
<span class="cm">     * @param      tlvValue        Buffer holding TLV value field.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">assetMetadataTLV</span><span class="p">)(</span><span class="w"></span>
<span class="w">            </span><span class="n">HAPAccessoryServer</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">tlvType</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">tlvLength</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">tlvValue</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The callback used to notify the accessory of asset metadata processing completion.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      server          Accessory server.</span>
<span class="cm">     * @param      accessory       The accessory that provides the service.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">assetMetadataComplete</span><span class="p">)(</span><span class="n">HAPAccessoryServer</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The callback used to provide the accessory with payload header information.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      server               Accessory server.</span>
<span class="cm">     * @param      accessory            The accessory that provides the service.</span>
<span class="cm">     * @param      payloadVersion       Payload version.</span>
<span class="cm">     * @param      payloadTag           Payload tag identifier.</span>
<span class="cm">     * @param      payloadLength        Payload length.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">payloadReady</span><span class="p">)(</span><span class="w"></span>
<span class="w">            </span><span class="n">HAPAccessoryServer</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">UARPVersion</span><span class="o">*</span><span class="w"> </span><span class="n">payloadVersion</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">payloadTag</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">payloadLength</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The callback used to notify the accessory of a payload metadata TLV for processing.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      server          Accessory server.</span>
<span class="cm">     * @param      accessory       The accessory that provides the service.</span>
<span class="cm">     * @param      tlvType         Type field of TLV.</span>
<span class="cm">     * @param      tlvLength       Length field of TLV.</span>
<span class="cm">     * @param      tlvValue        Buffer holding TLV value field.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">payloadMetadataTLV</span><span class="p">)(</span><span class="w"></span>
<span class="w">            </span><span class="n">HAPAccessoryServer</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">tlvType</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">tlvLength</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">tlvValue</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The callback used to notify the accessory of payload metadata processing completion.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      server          Accessory server.</span>
<span class="cm">     * @param      accessory       The accessory that provides the service.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">payloadMetadataComplete</span><span class="p">)(</span><span class="n">HAPAccessoryServer</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The callback used to notify the accessory of payload data.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      server          Accessory server.</span>
<span class="cm">     * @param      accessory       The accessory that provides the service.</span>
<span class="cm">     * @param      payloadTag      Payload tag identifier.</span>
<span class="cm">     * @param      offset          Offset for this data chunk.</span>
<span class="cm">     * @param      buffer          Buffer holding the data.</span>
<span class="cm">     * @param      bufferLength    Length of data buffer.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">payloadData</span><span class="p">)(</span><span class="w"></span>
<span class="w">            </span><span class="n">HAPAccessoryServer</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">payloadTag</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bufferLength</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The callback used to notify the accessory of payload processing completion.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      server          Accessory server.</span>
<span class="cm">     * @param      accessory       The accessory that provides the service.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">payloadDataComplete</span><span class="p">)(</span><span class="n">HAPAccessoryServer</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The callback used to notify the accessory of a change in asset state.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      server    Accessory server.</span>
<span class="cm">     * @param      accessory The accessory that provides the service.</span>
<span class="cm">     * @param      state     Asset state change.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">assetStateChange</span><span class="p">)(</span><span class="n">HAPAccessoryServer</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">,</span><span class="w"> </span><span class="n">UARPAssetStateChange</span><span class="w"> </span><span class="n">state</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The callback used to inform the accessory of an apply staged assets request.</span>
<span class="cm">     * It is expected that accepting the apply request will result in the accessory being reachable on the new firmware</span>
<span class="cm">     * version within the update duration time provided by the firmware update HAP profile.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      server            Accessory server.</span>
<span class="cm">     * @param      accessory         The accessory that provides the service.</span>
<span class="cm">     * @param[out] requestRefused    Accessory indicator for refusing the apply request.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">applyStagedAssets</span><span class="p">)(</span><span class="n">HAPAccessoryServer</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">requestRefused</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The callback used to retrieve the last accessory error.</span>
<span class="cm">     *</span>
<span class="cm">     * @param      server             Accessory server.</span>
<span class="cm">     * @param      accessory          The accessory that provides the service.</span>
<span class="cm">     * @param      lastErrorAction    Accessory last error and associated action.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">retrieveLastError</span><span class="p">)(</span><span class="w"></span>
<span class="w">            </span><span class="n">HAPAccessoryServer</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">UARPLastErrorAction</span><span class="o">*</span><span class="w"> </span><span class="n">lastErrorAction</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">UARPAccessoryCallbacks</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Initialize UARP.</span>
<span class="cm"> *</span>
<span class="cm"> * @param      server       HAP accessory server.</span>
<span class="cm"> * @param      accessory    HAP accessory containing accessory information.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">UARPInitialize</span><span class="p">(</span><span class="n">HAPAccessoryServer</span><span class="o">*</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">HAPAccessory</span><span class="o">*</span><span class="w"> </span><span class="n">accessory</span><span class="p">);</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm"> * Register for firmware assets.</span>
<span class="cm"> *</span>
<span class="cm"> * @param      callbacks                Callbacks for firmware asset events.</span>
<span class="cm"> * @param      stagedFirmwareVersion    Version of currently staged firmware.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="n">HAP_RESULT_USE_CHECK</span><span class="w"></span>
<span class="n">HAPError</span><span class="w"> </span><span class="n">UARPRegisterFirmwareAsset</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">UARPAccessoryFirmwareAssetCallbacks</span><span class="o">*</span><span class="w"> </span><span class="n">callbacks</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">UARPVersion</span><span class="o">*</span><span class="w"> </span><span class="n">stagedFirmwareVersion</span><span class="p">);</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm"> * Request a payload from the SuperBinary by payload index.</span>
<span class="cm"> * Payloads are indexed starting from 0.</span>
<span class="cm"> * It is expected the payload processing order will be built into the accessory&#39;s update scheme or will be derived</span>
<span class="cm"> * from the SuperBinary metadata.</span>
<span class="cm"> *</span>
<span class="cm"> * @param      payloadIndex    Payload index to begin pulling.</span>
<span class="cm"> *</span>
<span class="cm"> * @return kHAPError_None            If successful.</span>
<span class="cm"> * @return kHAPError_InvalidState    If there is no active asset.</span>
<span class="cm"> * @return kHAPError_InvalidData     If the payload index is invalid.</span>
<span class="cm"> * @return kHAPError_Unknown         If the UARP library is unable to process the request.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="n">HAP_RESULT_USE_CHECK</span><span class="w"></span>
<span class="n">HAPError</span><span class="w"> </span><span class="n">UARPRequestFirmwareAssetPayloadByIndex</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">payloadIndex</span><span class="p">);</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm"> * Changes the offset into the active payload.</span>
<span class="cm"> *</span>
<span class="cm"> * @param      payloadOffset   Relative offset into the payload.</span>
<span class="cm"> *</span>
<span class="cm"> * @return kHAPError_None            If successful.</span>
<span class="cm"> * @return kHAPError_InvalidState    If there is no active asset.</span>
<span class="cm"> * @return kHAPError_InvalidData     If the payload or payload offset is invalid.</span>
<span class="cm"> * @return kHAPError_Unknown         If the UARP library is unable to process the request.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="n">HAP_RESULT_USE_CHECK</span><span class="w"></span>
<span class="n">HAPError</span><span class="w"> </span><span class="n">UARPSetFirmwareAssetPayloadDataOffset</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">payloadOffset</span><span class="p">);</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm"> * Indicate the asset staging has been completed.</span>
<span class="cm"> *</span>
<span class="cm"> * @param      stagedVersion   Version of the update staged by the accessory.</span>
<span class="cm"> *</span>
<span class="cm"> * @return kHAPError_None            If successful.</span>
<span class="cm"> * @return kHAPError_InvalidState    If there is no active asset.</span>
<span class="cm"> * @return kHAPError_Unknown         If the UARP library was unable to process the request.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="n">HAP_RESULT_USE_CHECK</span><span class="w"></span>
<span class="n">HAPError</span><span class="w"> </span><span class="n">UARPFirmwareAssetFullyStaged</span><span class="p">(</span><span class="n">UARPVersion</span><span class="o">*</span><span class="w"> </span><span class="n">stagedVersion</span><span class="p">);</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm"> * Requests a change to the asset staging state.</span>
<span class="cm"> *</span>
<span class="cm"> * @param      state    Requested asset staging state change</span>
<span class="cm"> *</span>
<span class="cm"> * @return kHAPError_None            If successful.</span>
<span class="cm"> * @return kHAPError_InvalidState    If there is no active asset.</span>
<span class="cm"> * @return kHAPError_Unknown         If the UARP library is unable to process the request.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="n">HAP_RESULT_USE_CHECK</span><span class="w"></span>
<span class="n">HAPError</span><span class="w"> </span><span class="n">UARPRequestFirmwareAssetStagingStateChange</span><span class="p">(</span><span class="n">UARPAssetStagingStateChangeRequest</span><span class="w"> </span><span class="n">state</span><span class="p">);</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm"> * Checks if the UARP version is zero.</span>
<span class="cm"> *</span>
<span class="cm"> * @param      version    UARP Version.</span>
<span class="cm"> *</span>
<span class="cm"> * @return true     If all fields of the version are zero.</span>
<span class="cm"> * @return false    If at least one version field is non-zero.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">UARPIsVersionZero</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UARPVersion</span><span class="o">*</span><span class="w"> </span><span class="n">version</span><span class="p">);</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm"> * Checks if the UARP versions are equal.</span>
<span class="cm"> *</span>
<span class="cm"> * @param      version1    The 1st UARP Version for comparison.</span>
<span class="cm"> * @param      version2    The 2nd UARP Version for comparison.</span>
<span class="cm"> *</span>
<span class="cm"> * @return true     If all fields of the version are equal.</span>
<span class="cm"> * @return false    If at least one version field is not equal.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">UARPAreVersionsEqual</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">UARPVersion</span><span class="o">*</span><span class="w"> </span><span class="n">version1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UARPVersion</span><span class="o">*</span><span class="w"> </span><span class="n">version2</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p><em>Applications/Common/Helper/UARP.c</em></p>
<ul class="simple">
<li><p>Implements the accessory API interface to the UARP library.</p></li>
<li><p>Implements the binding layer between HDS and the UARP library.</p></li>
<li><p>Manages statically-allocated buffers to satisfy dynamic memory requests from the UARP library.</p></li>
</ul>
</li>
<li><p><em>Applications/Common/Helper/FirmwareUpdate.c</em></p>
<ul class="simple">
<li><p>Provides a sample implementation of the firmware update accessory interface, including UARP accessory callbacks and
basic state tracking to satisfy the HAP firmware update profile.</p></li>
<li><p>Provides an option for persisting the staged firmware version in the key value store (KVS).</p></li>
<li><p>Writes the firmware update payload data to a local file on POSIX based accessories. This data is saved in the
location specified by the value in <code class="docutils literal notranslate"><span class="pre">kFirmwareAssetFile</span></code>.</p></li>
<li><p>It does not provide an apply routine other than changing the firmware version reported by the accessory after a
simulated apply window. For accessories, it is expected a reboot will be needed to boot into the new firmware.
<code class="docutils literal notranslate"><span class="pre">HAPAccessoryServerStop()</span></code> can be called upon receiving an apply request to gracefully shut down the accessory
server prior to rebooting.</p></li>
<li><p>It provides limited support for the Firmware Update Readiness characteristic, which is dependent upon accessory-
specific decisions.</p></li>
<li><p>This file may be used as a reference implementation for integrating the firmware update feature into an accessory.</p></li>
</ul>
</li>
<li><p><em>Applications/</em>/App.c*</p>
<ul class="simple">
<li><p>All sample applications include support for firmware updates by:</p>
<ul>
<li><p>Including the firmware update and data stream transport management services in its services list.</p></li>
<li><p>Initializing HDS and the firmware update module.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="example-uarp-callback-flow">
<h3>Example UARP callback flow<a class="headerlink" href="#example-uarp-callback-flow" title="Permalink to this headline">¶</a></h3>
<p>If a controller determines it has an asset to offer and the accessory indicates it is ready to stage an update (via
the Firmware Update Readiness characteristic), the controller will set up an HDS session and proceed to offer the
asset. The ADK will validate the SuperBinary version is greater than that of the firmware currently running on the
device and there is not already a staged firmware with an equal or greater version. The asset offer will then be
forwarded to the accessory via <code class="docutils literal notranslate"><span class="pre">assetOffered()</span></code> for final confirmation to accept the asset. Should the accessory
choose not to accept the asset, the offer will be declined.</p>
<p>After an asset has been accepted to initiate staging, the SuperBinary header will be pulled first. If there is metadata
associated with the SuperBinary header, it will be pulled and each TLV will be provided to the accessory via
<code class="docutils literal notranslate"><span class="pre">assetMetadataTLV()</span></code>.</p>
<p>After all SuperBinary metadata TLVs have been processed, the accessory will be notified via <code class="docutils literal notranslate"><span class="pre">assetMetadataComplete()</span></code>.
The accessory must set the payload to pull via <code class="docutils literal notranslate"><span class="pre">UARPRequestPayloadByIndex()</span></code>. This allows an accessory to pull a subset
of payloads included in the SuperBinary, process payloads out-of-order, etc. It is expected this payload processing
order will be built into the accessory’s update scheme or will be derived from the SuperBinary metadata. Alternatively,
the payload headers may be iterated if logic is dependent upon payload information (version, tag) or payload metadata.</p>
<p>After the accessory has requested a payload, its corresponding header is pulled. Payload information will be provided
to the accessory via the <code class="docutils literal notranslate"><span class="pre">payloadReady()</span></code> callback once the header has been received and processed. After the callback
returns, any metadata associated with the payload will be pulled first, with each TLV provided to the accessory via
<code class="docutils literal notranslate"><span class="pre">payloadMetadataTLV()</span></code>. After all payload metadata TLVs have been processed, the accessory will be notified via
<code class="docutils literal notranslate"><span class="pre">payloadMetadataComplete()</span></code>. If payload information or metadata requires iterating payload headers and/or associated
metadata, a new payload can be requested using <code class="docutils literal notranslate"><span class="pre">UARPRequestPayloadByIndex()</span></code> in the <code class="docutils literal notranslate"><span class="pre">payloadReady()</span></code> or
<code class="docutils literal notranslate"><span class="pre">payloadMetadataComplete()</span></code> callbacks.</p>
<p>The accessory can also optionally set the payload data offset in the <code class="docutils literal notranslate"><span class="pre">payloadMetadataComplete()</span></code> callback. By
default, the accessory receives payload data from the controller starting at offset 0. By calling
<code class="docutils literal notranslate"><span class="pre">UARPSetPayloadDataOffset()</span></code>, the offset from which the accessory starts receiving payload data can be altered.
This may be useful in cases where the accessory resets or loses power during staging. Instead of re-transmitting the
entire firmware asset, the accessory can resume from its last known good offset. More information is available below
in <a class="reference external" href="#transfer-concepts">Transfer Concepts</a>.</p>
<p>Once <code class="docutils literal notranslate"><span class="pre">payloadMetadataComplete()</span></code> returns, the payload itself will be pulled based on the chunk size
<code class="docutils literal notranslate"><span class="pre">kUARPDataChunkSize</span></code>. Each payload chunk will be provided to the accessory via <code class="docutils literal notranslate"><span class="pre">payloadData()</span></code>.</p>
<p>After the entire payload has been provided, the accessory will be notified via <code class="docutils literal notranslate"><span class="pre">payloadDataComplete()</span></code>. At this point
the accessory may initiate pulling of another payload via <code class="docutils literal notranslate"><span class="pre">UARPRequestPayloadByIndex()</span></code> or indicate the asset has been
staged via <code class="docutils literal notranslate"><span class="pre">UARPAssetFullyStaged()</span></code>.</p>
<p>When a controller determines a staged update should be applied and the accessory indicates it is ready to do so
(via the Firmware Update Readiness characteristic), the accessory will be notified via <code class="docutils literal notranslate"><span class="pre">applyStagedAssets()</span></code>. If the
accessory’s readiness changes and it is no longer able to apply the update in accordance with <em>Section 2.1.2 - Applying
Update</em> of the HAP spec, it must refuse the request.</p>
<p>During staging, the controller may explicitly pause/resume the transfer. The accessory will be notified via
<code class="docutils literal notranslate"><span class="pre">assetStateChange()</span></code> with state <code class="docutils literal notranslate"><span class="pre">kUARPAssetStateChange_StagingPaused</span></code> and <code class="docutils literal notranslate"><span class="pre">kUARPAssetStateChange_StagingResumed</span></code>,
respectively. In addition, staging will also be paused if an HDS disconnect occurs or if a transfer stall condition is
detected due to timeout of a data request. In such scenarios, the accessory is notified of the pause such that the HAP
profile may be updated accordingly. When a controller connects and an offer is received such that staging may be
resumed, the accessory is again notified accordingly. The controller may also rescind a previously accepted asset,
either during staging or after staging has been completed. This event will be reflected by
<code class="docutils literal notranslate"><span class="pre">kUARPAssetStateChange_AssetRescinded</span></code> and the accessory should clear any partially or fully staged asset accordingly.
Should the UARP stack detect issues with asset formatting while processing the SuperBinary or payload headers, the
accessory will be notified with an event type of <code class="docutils literal notranslate"><span class="pre">kUARPAssetStateChange_AssetCorrupt</span></code> and the transfer will be
abandoned.</p>
<p>If an accessory’s staging readiness changes during the course of staging, it may alert the controller by setting a
relevant “Staging Not Ready Reason” bit in the HAP profile (reference <code class="docutils literal notranslate"><span class="pre">FwUpSetHAPProfileStagingNotReadyReason</span></code>).
This will generate a notification to the controller and the transfer will be paused. Upon clearing the bit, the
controller will resume staging.</p>
</div>
<div class="section" id="transfer-concepts">
<h3>Transfer Concepts<a class="headerlink" href="#transfer-concepts" title="Permalink to this headline">¶</a></h3>
<div class="section" id="controller-disconnect">
<h4>Controller disconnect<a class="headerlink" href="#controller-disconnect" title="Permalink to this headline">¶</a></h4>
<p>If an asset is accepted and a controller disconnect occurs prior to the accessory indicating the asset has been fully
processed, the asset will be “orphaned”. The accessory will be notified staging has been paused and the asset state
will be maintained within the UARP stack. If the controller re-connects or a secondary controller connects and offers
the same asset version, the transfer will be resumed. Note that the asset state maintained to resume a transfer is
stored in initialized RAM, meaning the UARP stack does not support resumes across resets.</p>
</div>
<div class="section" id="accessory-driven-resume">
<h4>Accessory-driven resume<a class="headerlink" href="#accessory-driven-resume" title="Permalink to this headline">¶</a></h4>
<p>If a reset or power loss occurs during staging which clears the UARP stack state, an accessory can optionally support
accessory-driven resume. In such a scenario, the <code class="docutils literal notranslate"><span class="pre">UARPRequestPayloadByIndex()</span></code> and <code class="docutils literal notranslate"><span class="pre">UARPSetPayloadDataOffset()</span></code> APIs
may be used by the accessory to jump to the desired offset based on the portion of the asset retained in the staging
area. This may be beneficial for accessories with large updates or those utilizing a transport with limited throughput,
resulting in lengthy staging times. Note that the accessory implementation is responsible for maintaining the staging
progress, performing asset comparison, and any validation of the partial asset to support accessory-driven resume. The
sample implementation uses the key value store for persisting payload progress. This allows for resuming after reset or
power loss. However, depending on the data chunk size being used and image size, this can result in a substantial
number of flash write cycles to maintain the progress state. Alternatively, non-initialized RAM could be used to
support resume across just resets, a resume offset could be determined by examining the staging area contents, or the
storage of progress to persistent memory could be performed less frequently (e.g. every N payload data callbacks) with
appropriate resume cleanup to lessen the overhead and flash wear. How, and even whether, accessory-driven resume should
be supported is left up to the accessory vendor based on system design.</p>
</div>
<div class="section" id="competing-offers">
<h4>Competing offers<a class="headerlink" href="#competing-offers" title="Permalink to this headline">¶</a></h4>
<p>After an asset has been accepted, it is possible for a competing asset to be offered to the accessory. This may be done
either while actively staging the initial asset or after the initial asset has been staged but not applied. If the
accessory wishes to accept the new asset, it must first explicitly abandon the previously accepted asset. This is done
by calling <code class="docutils literal notranslate"><span class="pre">UARPRequestAssetStagingStateChange()</span></code> with <code class="docutils literal notranslate"><span class="pre">kUARPAssetStagingStateChangeRequest_Abandon</span></code>. Note that an
offer made to the accessory layer will have a version which has passed the initial version checks against the active
firmware and any fully staged version. In addition, if actively staging an asset, the offered version will also be
greater than that which is currently being staged.</p>
</div>
<div class="section" id="minimum-firmware-version">
<h4>Minimum firmware version<a class="headerlink" href="#minimum-firmware-version" title="Permalink to this headline">¶</a></h4>
<p>SuperBinary assets may be packaged such that any required minimum running version is available alongside the desired
update version. In such a scenario, the accessory can pull the payload(s) corresponding to the minimum version and
indicate staging is complete. The “Apply Needed” staging not ready reason needs to be set by the accessory to indicate
to the controller that the currently staged version needs to be applied in order to update to the firmware version
equivalent to that of the asset offer. Upon applying the minimum version and receiving an offer for the initial
SuperBinary asset again, the payload(s) corresponding to the final version can then be pulled. Note that the accessory
firmware would need to have knowledge of minimum firmware versions and appropriate handling baked into the running
version upon receiving the asset offer. More information can be found in <em>Section 3 - SuperBinary</em> of the UARP
development guide.</p>
</div>
<div class="section" id="transport-optimization">
<h4>Transport Optimization<a class="headerlink" href="#transport-optimization" title="Permalink to this headline">¶</a></h4>
<p>The UARP protocol and HDS add overhead to the raw asset data that is being delivered to the accessory.</p>
<ul class="simple">
<li><p>Each HDS frame includes a 4 byte header and 38 bytes of overhead associated with the HDS stream protocol.</p></li>
<li><p>Each UARP data response message header is 18 bytes.</p></li>
</ul>
<p>For IP accessories, an authentication tag of 16 bytes is appended to each HDS frame in accordance with HDS over TCP
frame format. Therefore, each chunk of staging data has an associated 76 bytes of overhead. The primary factor which
can be used to improve staging performance is the data chunk size, <code class="docutils literal notranslate"><span class="pre">kUARPDataChunkSize</span></code>, at a memory cost to support
larger buffers. The default data chunk size for IP accessories is 8 KB.</p>
<p>For BLE accessories, there is additional overhead associated with the BLE HAP PDU and HDS HAP transport:</p>
<ul class="simple">
<li><p>The HAP PDU header and PDU body overhead is 10 bytes. If the HAP PDU is fragmented across multiple BLE packets, the
HAP PDU Header is 2 bytes for subsequent BLE packets.</p></li>
<li><p>Each BLE packet includes a 16 byte HAP PDU Auth Tag.</p></li>
<li><p>HDS data sent over the HAP transport is packed in TLV8 chunks, adding 2 bytes of overhead for every 255 bytes of HDS
data. The HAP transport also adds 3 bytes of overhead per write to the transport characteristic to specify the
session identifier associated with the data stream.</p></li>
</ul>
<p>The data chunk size is again the primary variable for improving staging throughput. In addition to decreasing the
overhead per byte of staging data, larger data chunks decrease the number of write-responses the controller must
perform on the HAP transport characteristic.</p>
<p>Another factor to take into account is the BLE GATT MTU. The larger the MTU, the less HAP PDU overhead and the fewer
write-responses required for a fixed staging data size. For example, consider the default data chunk size for BLE
accessories of 512 bytes with a BLE MTU of 512 bytes as well.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>BLE Packet <span class="m">1</span>:

HAP PDU header and body overhead: <span class="m">10</span> bytes
    HAP transport TLV <span class="o">(</span>payload<span class="o">)</span>: <span class="m">2</span> bytes
        HDS header: <span class="m">46</span> bytes
            UARP data response header: <span class="m">18</span> bytes
                UARP data response payload: <span class="m">191</span> bytes
    HAP transport TLV <span class="o">(</span>payload<span class="o">)</span>: <span class="m">2</span> bytes
                UARP data response payload: <span class="m">227</span> bytes
HAP PDU auth tag: <span class="m">16</span> bytes

BLE Packet <span class="m">2</span>:

HAP PDU header: <span class="m">2</span> bytes
                UARP data response payload: <span class="m">28</span> bytes
    HAP transport TLV <span class="o">(</span>payload<span class="o">)</span>: <span class="m">2</span> bytes
                UARP data response payload: <span class="m">66</span> bytes
    HAP transport TLV <span class="o">(</span>session id<span class="o">)</span>: <span class="m">3</span> bytes
HAP PDU auth tag: <span class="m">16</span> bytes
</pre></div>
</div>
<p>In this case, the first BLE PDU fragment carries 418 bytes of staging data while the remaining 94 bytes correspond to
message overhead. The second BLE PDU fragment carries 94 bytes of staging data with 23 bytes of overhead and the
remaining 395 bytes of the MTU unused.</p>
<p>Note that the BLE GATT MTU is negotiated with iOS and therefore may not be statically optimized, but in general support
for a larger MTU on the accessory side improves the chances of lessening the overhead associated with staging an update
to the device.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="homekit_bridge.html" class="btn btn-neutral float-right" title="HomeKit Bridge" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="appletv_remote.html" class="btn btn-neutral float-left" title="Apple TV Remote" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright © 2021 Apple Inc. All Rights Reserved..

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>