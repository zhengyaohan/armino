diff --git a/Makefile.am b/Makefile.am
index 2c9490f5f..7d94b753c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -205,7 +205,7 @@ src_bluetoothd_LDADD = lib/libbluetooth-internal.la \
 			src/libshared-glib.la \
 			@BACKTRACE_LIBS@ @GLIB_LIBS@ @DBUS_LIBS@ -ldl -lrt \
 			$(builtin_ldadd)
-src_bluetoothd_LDFLAGS = $(AM_LDFLAGS) -Wl,--export-dynamic \
+src_bluetoothd_LDFLAGS = $(AM_LDFLAGS) -pthread -Wl,--export-dynamic \
 				-Wl,--version-script=$(srcdir)/src/bluetooth.ver
 
 src_bluetoothd_DEPENDENCIES = lib/libbluetooth-internal.la \
@@ -213,7 +213,7 @@ src_bluetoothd_DEPENDENCIES = lib/libbluetooth-internal.la \
 				src/libshared-glib.la \
 				src/bluetooth.service
 
-src_bluetoothd_CFLAGS = $(AM_CFLAGS) -DBLUETOOTH_PLUGIN_BUILTIN \
+src_bluetoothd_CFLAGS = $(AM_CFLAGS) -pthread -DBLUETOOTH_PLUGIN_BUILTIN \
 					-DPLUGINDIR=\""$(build_plugindir)"\"
 src_bluetoothd_SHORTNAME = bluetoothd
 
diff --git a/src/adapter.c b/src/adapter.c
index af340fd6e..8c330d149 100644
--- a/src/adapter.c
+++ b/src/adapter.c
@@ -29,6 +29,8 @@
 #include <stdio.h>
 #include <inttypes.h>
 #include <errno.h>
+#include <poll.h>
+#include <pthread.h>
 #include <unistd.h>
 #include <stdlib.h>
 #include <stdbool.h>
@@ -78,6 +80,9 @@
 #include "advertising.h"
 #include "eir.h"
 
+#include "hci.h"
+#include "hci_lib.h"
+
 #define ADAPTER_INTERFACE	"org.bluez.Adapter1"
 
 #define MODE_OFF		0x00
@@ -167,6 +172,15 @@ struct watch_client {
 	struct discovery_filter *discovery_filter;
 };
 
+struct passive_scan_client {
+	struct btd_adapter *adapter;
+	int dev_id;
+	char *owner;
+	guint watch;
+	pthread_t thread;
+	bool stop_thread;
+};
+
 struct service_auth {
 	guint id;
 	unsigned int svc_id;
@@ -222,6 +236,7 @@ struct btd_adapter {
 	GSList *set_filter_list;	/* list of clients that specified
 					 * filter, but don't scan yet
 					 */
+	GSList *passive_scan_list;  /* list of passive scan clients */
 	/* current discovery filter, if any */
 	struct mgmt_cp_start_service_discovery *current_discovery_filter;
 
@@ -1884,6 +1899,14 @@ static int compare_sender(gconstpointer a, gconstpointer b)
 	return g_strcmp0(client->owner, sender);
 }
 
+static int compare_passive_scan_sender(gconstpointer a, gconstpointer b)
+{
+	const struct passive_scan_client *client = a;
+	const char *sender = b;
+
+	return g_strcmp0(client->owner, sender);
+}
+
 static gint g_strcmp(gconstpointer a, gconstpointer b)
 {
 	return strcmp(a, b);
@@ -3284,6 +3307,259 @@ static DBusMessage *connect_device(DBusConnection *conn,
 	return NULL;
 }
 
+static bool get_passive_scan_client(struct btd_adapter *adapter,
+						const char *owner,
+						struct passive_scan_client **client)
+{
+	GSList *list = g_slist_find_custom(adapter->passive_scan_list, owner,
+								compare_passive_scan_sender);
+	if (list) {
+		*client = list->data;
+		return true;
+	}
+
+	*client = NULL;
+	return false;
+}
+
+static void passive_scan_handle_stop_signal(int sig, siginfo_t *info, void *ucontext)
+{
+}
+
+static void *passive_scan_thread_entry(void* user_data) {
+	struct sigaction sa;
+	int dd, err;
+	struct hci_filter nf;
+	struct passive_scan_client *client = user_data;
+
+	dd = hci_open_dev(client->dev_id);
+	if (dd <0) {
+		btd_error(client->dev_id, "Could not open hci device");
+		return NULL;
+	}
+
+	err = hci_le_set_scan_parameters(dd, 0x00, htobs(0x0010), htobs(0x0010),
+				LE_PUBLIC_ADDRESS, 0x00, 10000);
+	if (err < 0) {
+		btd_error(client->dev_id, "Could not set scan parameters: %s", strerror(errno));
+		hci_close_dev(dd);
+		return NULL;
+	}
+
+	err = hci_le_set_scan_enable(dd, 0x01, 0x00, 10000);
+	if (err < 0) {
+		btd_error(client->dev_id, "Could not enable scan: %s", strerror(errno));
+		hci_close_dev(dd);
+		return NULL;
+	}
+
+	hci_filter_clear(&nf);
+	hci_filter_set_ptype(HCI_EVENT_PKT, &nf);
+	hci_filter_set_event(EVT_LE_META_EVENT, &nf);
+
+	if (setsockopt(dd, SOL_HCI, HCI_FILTER, &nf, sizeof nf) < 0) {
+		btd_error(client->dev_id, "Could not set socket options: %s", strerror(errno));
+		hci_close_dev(dd);
+		return NULL;
+	}
+
+	memset(&sa, 0, sizeof sa);
+	sa.sa_flags = SA_SIGINFO;
+	sa.sa_handler = NULL;
+	sa.sa_sigaction = passive_scan_handle_stop_signal;
+	if (sigaction(SIGUSR1, &sa, NULL)) {
+		btd_error(client->dev_id, "Could not setup signal handler");
+		hci_close_dev(dd);
+		return NULL;
+	}
+
+	while (!client->stop_thread) {
+		evt_le_meta_event *meta;
+		uint8_t count;
+		unsigned char buf[HCI_MAX_EVENT_SIZE];
+		int len;
+		unsigned char *ptr;
+		uint8_t *dataptr;
+		GError *error;
+		GVariantBuilder *builder;
+		GVariant *args;
+		DBusMessage *signal;
+		DBusMessageIter iter;
+		int ret;
+		struct pollfd fds[1];
+		fds[0].fd = dd;
+		fds[0].events = POLLERR | POLL_HUP | POLLIN;
+		fds[0].revents = 0;
+
+		// Note that SIGUSR1 could be issued between client->stop_thread check and read()
+		// call below and hence use poll() to at least timeout and catch those cases.
+		len = poll(fds, 1, 2000);
+		if (len == -1) {
+			if (errno == EAGAIN || errno == EINTR)
+				continue;
+			DBG("Unexpected poll errno %d", errno);
+			break;
+		}
+		if (len == 0) // timeout
+			continue;
+
+		len = read(dd, buf, sizeof(buf));
+		if (len < 0) {
+			if (errno == EAGAIN || errno == EINTR)
+				continue;
+
+			DBG("Unexpected read errno %d", errno);
+			break;
+		}
+
+		ptr = buf + (1 + HCI_EVENT_HDR_SIZE);
+		len -= (1 + HCI_EVENT_HDR_SIZE);
+
+		meta = (void *) ptr;
+
+		if (meta->subevent != 0x02) {
+			DBG("Unexpected subevent %x", meta->subevent);
+			break;
+		}
+
+		count = meta->data[0];
+		dataptr = &meta->data[1];
+
+		signal = dbus_message_new_signal(client->adapter->path,
+			ADAPTER_INTERFACE, "DiscoveredDevices");
+		if (signal == NULL) {
+			btd_error(client->dev_id, "Unable to allocate new " ADAPTER_INTERFACE ".DiscoveredDevices signal");
+			continue;
+		}
+
+		dbus_message_iter_init_append(signal, &iter);
+
+		while (count--) {
+			le_advertising_info* info = (le_advertising_info *) dataptr;
+			DBusMessageIter element_iter, info_iter, byte_iter;
+			uint8_t addr[6];
+
+			baswap((bdaddr_t *) addr, &info->bdaddr);
+
+			dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,
+					"(ayyayy)", &element_iter);
+			dbus_message_iter_open_container(&element_iter, DBUS_TYPE_STRUCT, NULL, &info_iter);
+
+			dbus_message_iter_open_container(&info_iter, DBUS_TYPE_ARRAY, "y", &byte_iter);
+			for (size_t i = 0; i < sizeof addr; i++) {
+				dbus_message_iter_append_basic(&byte_iter, DBUS_TYPE_BYTE, &addr[i]);
+			}
+			dbus_message_iter_close_container(&info_iter, &byte_iter);
+			dbus_message_iter_append_basic(&info_iter, DBUS_TYPE_BYTE, &info->bdaddr_type);
+
+			dbus_message_iter_open_container(&info_iter, DBUS_TYPE_ARRAY, "y", &byte_iter);
+			for (size_t i = 0; i < info->length; i++) {
+				dbus_message_iter_append_basic(&byte_iter, DBUS_TYPE_BYTE, &info->data[i]);
+			}
+			dbus_message_iter_close_container(&info_iter, &byte_iter);
+
+			uint8_t rssi = info->data[info->length];
+
+			dbus_message_iter_append_basic(&info_iter, DBUS_TYPE_BYTE, &rssi);
+			dbus_message_iter_close_container(&element_iter, &info_iter);
+			dbus_message_iter_close_container(&iter, &element_iter);
+
+			dataptr += sizeof(*info) + info->length + 1;
+		}
+
+		// emit signal
+		dbus_connection_send(dbus_conn, signal, NULL);
+		dbus_message_unref(signal);
+	}
+
+	err = hci_le_set_scan_enable(dd, 0x00, 0x01, 10000);
+	if (err < 0) {
+		hci_close_dev(dd);
+		btd_error(client->dev_id, "Could not disable scan");
+	}
+
+	hci_close_dev(dd);
+	return NULL;
+}
+
+static void passive_scan_disconnect(DBusConnection *conn, void *user_data)
+{
+	struct passive_scan_client *client = user_data;
+
+	DBG("owner %s", client->owner);
+
+	client->stop_thread = true;
+	pthread_kill(client->thread, SIGUSR1);
+	pthread_join(client->thread, NULL);
+	client->adapter->passive_scan_list = g_slist_remove(client->adapter->passive_scan_list, client);
+	free(client->owner);
+	g_free(client);
+}
+
+static DBusMessage *start_passive_scan(DBusConnection *conn,
+					DBusMessage *msg, void *user_data)
+{
+	struct btd_adapter *adapter = user_data;
+	const char *sender = dbus_message_get_sender(msg);
+	struct passive_scan_client *client;
+
+	DBG("sender %s", sender);
+
+	if (get_passive_scan_client(adapter, sender, &client)) {
+		/* Scan was already requested */
+		return btd_error_failed(msg, strerror(EBUSY));
+	}
+
+	client = g_new0(struct passive_scan_client, 1);
+	if (!client) {
+		return btd_error_failed(msg, strerror(ENOMEM));
+	}
+
+	client->adapter = adapter;
+	client->dev_id = adapter->dev_id;
+	client->owner = g_strdup(sender);
+	client->stop_thread = false;
+	if (pthread_create(&client->thread, NULL, passive_scan_thread_entry, client) != 0) {
+		free(client->owner);
+		g_free(client);
+		return btd_error_failed(msg, strerror(ENOMEM));
+	}
+
+	client->watch = g_dbus_add_disconnect_watch(dbus_conn, sender,
+						passive_scan_disconnect, client,
+						NULL);
+	adapter->passive_scan_list = g_slist_prepend(adapter->passive_scan_list,
+								client);
+	return dbus_message_new_method_return(msg);
+}
+
+static DBusMessage *stop_passive_scan(DBusConnection *conn,
+					DBusMessage *msg, void *user_data)
+{
+	struct btd_adapter *adapter = user_data;
+	const char *sender = dbus_message_get_sender(msg);
+	struct passive_scan_client *client;
+	int err;
+
+	DBG("sender %s", sender);
+
+	if (!get_passive_scan_client(adapter, sender, &client)) {
+		return btd_error_failed(msg, strerror(EINVAL));
+	}
+
+	if (client->watch) {
+		g_dbus_remove_watch(dbus_conn, client->watch);
+	}
+	client->stop_thread = true;
+	pthread_kill(client->thread, SIGUSR1);
+	pthread_join(client->thread, NULL);
+	client->adapter->passive_scan_list = g_slist_remove(client->adapter->passive_scan_list, client);
+	free(client->owner);
+	g_free(client);
+
+	return dbus_message_new_method_return(msg);
+}
+
 static const GDBusMethodTable adapter_methods[] = {
 	{ GDBUS_ASYNC_METHOD("StartDiscovery", NULL, NULL, start_discovery) },
 	{ GDBUS_METHOD("SetDiscoveryFilter",
@@ -3298,6 +3574,9 @@ static const GDBusMethodTable adapter_methods[] = {
 	{ GDBUS_EXPERIMENTAL_ASYNC_METHOD("ConnectDevice",
 				GDBUS_ARGS({ "properties", "a{sv}" }), NULL,
 				connect_device) },
+	// New methods to support passive LE scan
+	{ GDBUS_EXPERIMENTAL_ASYNC_METHOD("StartPassiveScan", NULL, NULL, start_passive_scan) },
+	{ GDBUS_EXPERIMENTAL_ASYNC_METHOD("StopPassiveScan", NULL, NULL, stop_passive_scan) },
 	{ }
 };
 
diff --git a/src/advertising.c b/src/advertising.c
index 625750c4f..e7cb97598 100644
--- a/src/advertising.c
+++ b/src/advertising.c
@@ -41,6 +41,9 @@
 
 #define LE_ADVERTISING_MGR_IFACE "org.bluez.LEAdvertisingManager1"
 #define LE_ADVERTISEMENT_IFACE "org.bluez.LEAdvertisement1"
+#define DEBUGFS_ROOT "/sys/kernel/debug/bluetooth"
+#define DEBUGFS_ADV_MIN_INTERVAL "adv_min_interval"
+#define DEBUGFS_ADV_MAX_INTERVAL "adv_max_interval"
 
 struct btd_adv_manager {
 	struct btd_adapter *adapter;
@@ -65,6 +68,7 @@ struct btd_adv_client {
 	uint16_t appearance;
 	uint16_t duration;
 	uint16_t timeout;
+	uint16_t interval;
 	uint16_t discoverable_to;
 	unsigned int to_id;
 	unsigned int disc_to_id;
@@ -696,6 +700,22 @@ fail:
 	return false;
 }
 
+static bool parse_interval(DBusMessageIter *iter,
+					struct btd_adv_client *client)
+{
+	if (!iter) {
+		client->interval = 0x800; // default
+		return true;
+	}
+
+	if (dbus_message_iter_get_arg_type(iter) != DBUS_TYPE_UINT16)
+		return false;
+
+	dbus_message_iter_get_basic(iter, &client->interval);
+
+	return true;
+}
+
 static size_t calc_max_adv_len(struct btd_adv_client *client, uint32_t flags)
 {
 	size_t max = client->manager->max_adv_len;
@@ -717,6 +737,22 @@ static size_t calc_max_adv_len(struct btd_adv_client *client, uint32_t flags)
 	return max;
 }
 
+static void add_name_to_adv(uint32_t flags, struct btd_adv_client *client, struct bt_ad* data)
+{
+	struct btd_adv_manager *manager = client->manager;
+	const char *name;
+
+	if (!(flags & MGMT_ADV_FLAG_LOCAL_NAME) && !client->name) {
+		return;
+	}
+
+	name = client->name;
+	if (!name)
+		name = btd_adapter_get_name(manager->adapter);
+
+	bt_ad_add_name(data, name);
+}
+
 static uint8_t *generate_adv_data(struct btd_adv_client *client,
 						uint32_t *flags, size_t *len)
 {
@@ -734,15 +770,43 @@ static uint8_t *generate_adv_data(struct btd_adv_client *client,
 		bt_ad_add_appearance(client->data, appearance);
 	}
 
+	add_name_to_adv(*flags, client, client->data);
+
 	return bt_ad_generate(client->data, len);
 }
 
+static gboolean adv_data_has_complete_name(uint8_t *adv_data, size_t len)
+{
+	while (len > 0) {
+		uint8_t segment_len = *adv_data++;
+		len--;
+		if (segment_len > len) {
+			error("Bad advertisement binary data");
+			break;
+		}
+		if (segment_len > 0 && len > 0) {
+			uint8_t ad_type = *adv_data;
+			if (ad_type == BT_AD_NAME_COMPLETE) {
+				return true;
+			}
+		}
+		len -= segment_len;
+		adv_data += segment_len;
+	}
+	return FALSE;
+}
+
 static uint8_t *generate_scan_rsp(struct btd_adv_client *client,
-						uint32_t *flags, size_t *len)
+						gboolean include_name, uint32_t *flags, size_t *len)
 {
 	struct btd_adv_manager *manager = client->manager;
 	const char *name;
 
+	if (!include_name) {
+		*len = 0;
+		return NULL;
+	}
+
 	if (!(*flags & MGMT_ADV_FLAG_LOCAL_NAME) && !client->name) {
 		*len = 0;
 		return NULL;
@@ -759,6 +823,61 @@ static uint8_t *generate_scan_rsp(struct btd_adv_client *client,
 	return bt_ad_generate(client->scan, len);
 }
 
+static void update_adv_interval(struct btd_adv_client *client)
+{
+	char path[128];
+	char value[6]; // uint16 value in string
+	int sz, count;
+	FILE *fp;
+	unsigned current_max_interval;
+
+	sz = snprintf(path, sizeof path, DEBUGFS_ROOT "/hci%u/" DEBUGFS_ADV_MAX_INTERVAL, client->manager->mgmt_index);
+	if (sz >= sizeof path) {
+		error("Debug filesystem adv_max_interval path longer than internal buffer.");
+		return;
+	}
+
+	fp = fopen(path, "rt");
+	if (!fp) {
+		error("Cannot open %s for reading.", path);
+		return;
+	}
+	count = fscanf(fp, "%u", &current_max_interval);
+	fclose(fp);
+	if (count != 1) {
+		error("Cannot read interval from %s.", path);
+		return;
+	}
+
+	// Linux kernel does not allow writing an interval that makes min > max at any time.
+	// Hence, the order of min, max interval writing must depend on the current value.
+	size_t write_max_first = (current_max_interval < client->interval)? 1: 0;
+
+	for (size_t i = 0; i < 2; i++) {
+		if ((i ^ write_max_first) == 0) {
+			// Write min interval first if current_max_interval >= client->interval.
+			// Write min interval after writing max interval if current_max_interval < client->interval.
+			sz = snprintf(path, sizeof path, DEBUGFS_ROOT "/hci%u/" DEBUGFS_ADV_MIN_INTERVAL, client->manager->mgmt_index);
+		} else {
+			// Write max interval first if current_max_interval < client->interval.
+			// Write max interval after writing min interval if current_max_interval >= client->interval.
+			sz = snprintf(path, sizeof path, DEBUGFS_ROOT "/hci%u/" DEBUGFS_ADV_MAX_INTERVAL, client->manager->mgmt_index);
+		}
+		if (sz >= sizeof path) {
+			error("Debug filesystem path longer than internal buffer.");
+			return;
+		}
+
+		fp = fopen(path, "wt");
+		if (!fp) {
+			error("Cannot open %s for writing interval.", path);
+			return;
+		}
+		fprintf(fp, "%u", client->interval);
+		fclose(fp);
+	}
+}
+
 static int refresh_adv(struct btd_adv_client *client, mgmt_request_func_t func)
 {
 	struct mgmt_cp_add_advertising *cp;
@@ -787,7 +906,10 @@ static int refresh_adv(struct btd_adv_client *client, mgmt_request_func_t func)
 		return -EINVAL;
 	}
 
-	scan_rsp = generate_scan_rsp(client, &flags, &scan_rsp_len);
+	// Complete name doesn't have to repeat in the scan response if it is included in the adv_ind.
+	// However, it appears that HCI will build its own scan response if the scan response is empty.
+	// Hence, scan response shall always include name regardless.
+	scan_rsp = generate_scan_rsp(client, TRUE, &flags, &scan_rsp_len);
 	if (!scan_rsp && scan_rsp_len) {
 		error("Scan data couldn't be generated.");
 		free(adv_data);
@@ -801,7 +923,8 @@ static int refresh_adv(struct btd_adv_client *client, mgmt_request_func_t func)
 	if (!cp) {
 		error("Couldn't allocate for MGMT!");
 		free(adv_data);
-		free(scan_rsp);
+		if (scan_rsp)
+			free(scan_rsp);
 		return -ENOMEM;
 	}
 
@@ -811,10 +934,14 @@ static int refresh_adv(struct btd_adv_client *client, mgmt_request_func_t func)
 	cp->adv_data_len = adv_data_len;
 	cp->scan_rsp_len = scan_rsp_len;
 	memcpy(cp->data, adv_data, adv_data_len);
-	memcpy(cp->data + adv_data_len, scan_rsp, scan_rsp_len);
+	if (scan_rsp)
+		memcpy(cp->data + adv_data_len, scan_rsp, scan_rsp_len);
 
 	free(adv_data);
-	free(scan_rsp);
+	if (scan_rsp)
+		free(scan_rsp);
+
+	update_adv_interval(client);
 
 	if (!mgmt_send(client->manager->mgmt, MGMT_OP_ADD_ADVERTISING,
 				client->manager->mgmt_index, param_len, cp,
@@ -886,6 +1013,7 @@ static struct adv_parser {
 	{ "Data", parse_data },
 	{ "Discoverable", parse_discoverable },
 	{ "DiscoverableTimeout", parse_discoverable_timeout },
+	{ "Interval", parse_interval },
 	{ },
 };
 
diff --git a/src/bluetooth.service.in b/src/bluetooth.service.in
index f799f65f0..9dd9ba6f0 100644
--- a/src/bluetooth.service.in
+++ b/src/bluetooth.service.in
@@ -6,7 +6,7 @@ ConditionPathIsDirectory=/sys/class/bluetooth
 [Service]
 Type=dbus
 BusName=org.bluez
-ExecStart=@libexecdir@/bluetoothd
+ExecStart=+@libexecdir@/bluetoothd -d --experimental --noplugin=battery
 NotifyAccess=main
 #WatchdogSec=10
 #Restart=on-failure
diff --git a/src/device.c b/src/device.c
index 4f1af7012..b4fdf3c54 100644
--- a/src/device.c
+++ b/src/device.c
@@ -468,7 +468,7 @@ static bool device_address_is_private(struct btd_device *dev)
 	switch (dev->bdaddr.b[5] >> 6) {
 	case 0x00:	/* Private non-resolvable */
 	case 0x01:	/* Private resolvable */
-		return true;
+		return false;
 	default:
 		return false;
 	}
